
* * * * * * * * * * * * * * * * * 
* * * BDS windows版 插件工程
* * * 使用说明
* * * * * * * * * * * * * * * * * 

该工程用来生成供Windows版BDS使用的插件，为了让开发者能更加顺利开发，需要说明：

一、该插件的原理是：利用PDB导出工具导出SymHook.h，然后利用SymHook内的函数地址，
对函数进行Hook，达到我们想要的目的。SymHook内部实际上是保存了每个符号导出的RVA，
也就是相对虚拟地址，当开服器启动的时候，开服器内部的二进制机器码段.text将被加载，
加载到一个被称为“模块基址”的位置，而我们要找到我们想Hook的函数地址，就得通过寻找
“模块基址”，然后加上我们这个函数RVA相对位置。这个“模块基址”是运行时确定的，但是
没有关系，我们的插件是动态计算这个地址的。那么需要注意的问题是，当BDS更新新版本，
我们的插件也要使用PDB工具重新生成每个符号的RVA，重新编译，才能适应新版本。不然，
将可能导致开服器无法工作，甚至崩溃。也可能会出现新版本删除某些函数，导致插件无法
适配新版本，这时候就得重新分析新版本的开服器，重新设计编写插件。

二、当你使用IDA Pro分析BDS核心程序的时候，最好将Windows版和Linux版同时下载下来
分析，因为Mojang提供的两种版本编译后的结果是不同的，Linux版接近完全不优化，几乎
每个函数都存在于编译后的程序文件中，很容易找到并Hook，可读性极高，但Windows版就
没有这么好了，Windows版内部因为用函数内联优化干掉了很多长度很短的函数，有些还是
类的构造函数，给逆向分析理解带来了巨大的麻烦，被优化掉的函数是无法通过符号来Hook
的，也给开发插件带来了一些阻力。在这种困难的情况下，看一看同一版本的Linux实现是
十分有用的。

三、在mod.cpp文件说过了，“T”系列的宏是从MCMrARM那里移植来的，除了符号部分的使用
是不同的，其他都保留了原汁原味，如果你开发过modloader的插件，相信你可以很快适应
该工程的开发节奏：
以下“T”开头宏构造一个全局的struct结构体，然后利用结构体的构造函数来做Hook的工作，
那么这些Hook动作将先于Dllmain函数执行，也就是先于mod_init函数执行，这点请注意。
THook					用来hook全局函数，不包含在任何类的那种，比如int abc(int);
TInstanceHook			用来hook有完整的类定义的成员函数；
TClasslessInstanceHook	用来hook没有完整类定义的成员函数；
TStaticHook				用来hook有完整的类定义中的静态函数的。
如果你想在同一个mod模块内hook同一个函数超过一次，那么请用后缀有2的宏。
大体的使用方式是：
THook(返回值, 函数符号C++变量, 参数...) { Hook后的有效的函数过程 }
结构体内有个original变量，指向的是被hook前的原始函数，可以用它调用原先的函数。
另外几个使用细节上跟THook肯定是有所不同的，请仔细观察使用哦！
更多请访问：https://github.com/minecraft-linux/server-modloader/wiki/Hooking-API
你可以选择不用“T”系列的宏，在mod_init函数内使用Hook与UnHook函数实现hook。
两种实现hook功能的方式可以共存，而且互不干扰。

四、关于我自己写的SYM_CALL系列宏，首先SYM_CALL的使用方法是：
返回值 = SYM_CALL(函数指针类型, 函数符号C++变量, 参数...)
如果没有返回值，返回值部分可以省略。
该功能将使用符号的RVA来调用它，您可以使用它来调用开服器内原有的函数。
然后由这个SYM_CALL继续写了16个以数字结尾（0到15）的宏，这些宏将简化了对一个不知
参数类型但知道参数个数的函数的调用，和SYM_CALL相比，它省略了函数指针类型，而利用
结尾的数字假定了一个函数类型。每一个的类型都是VA，也就是unsigned __int64，包括
返回值，如果你知道其中某一些参数的实际类型并且想使用它，那么你需要使用
reinterpret_cast来转换这个参数类型为你所想要的类型。这里举一个使用案例：
假如有个函数int add(int, int)，通过工具你获取到了它符号对应的C++变量MSSYM_XXXX，
然后根据它的参数个数，也就是2，来选取对应尾数的宏：SYM_CALL_2，然后使用它
auto ret = SYM_CALL_2(MSSYM_XXXX, reinterpret_cast<VA>(2), reinterpret_cast<VA>(3));
int result = reinterpret_cast<int>(ret);
于是这样就实现了add函数调用。
这里VA本意为进程虚拟地址的意思，但它在二进制上等同与调用约定传递的值的尺寸，所以
用它替代未知函数参数类型。

五、由于本工程使用微软官方的Hook库detour，会在编译后的插件文件体现它的体积，所以
我不建议开发者将不同功能的插件分开到不同的插件工程去编译，这样做虽说不是不可以，
但是会增加插件部分的冗余体积。

六、工具“BDS 简易启动器”在启动的流程上使用插件优先加载的原则，会使得插件的加载过程
先于开服器主线程启动，所以在插件加载的时候千万不要认为开服器全局变量已经被初始化！
更不要尝试去使用这些值，因为它们是无意义的！

七、由于UWP平台限制，如果你想用win10版客户端来测试本机启动的开服器，请务必保证
UWP应用访问本地网络的限制解除。否则win10版客户端将无法定位本机启动的开服器。
BDS自带Howto教程有讲到解除的方法。

最后，祝您开发愉快！

